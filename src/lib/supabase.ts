import { createClient } from '@supabase/supabase-js'
import { v4 as uuidv4 } from 'uuid';

// Creden»õialele Supabase pentru proiectul tƒÉu
const supabaseUrl = 'https://tidnmzsivsthwwcfdzyo.supabase.co'
const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRpZG5tenNpdnN0aHd3Y2ZkenlvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA3MjE5NTgsImV4cCI6MjA2NjI5Nzk1OH0.Sr1gSZ2qtoff7gmulkT8uIzB8eL7gqKUUNVj82OqHog'

export const supabase = createClient(supabaseUrl, supabaseAnonKey)

// Tipuri pentru baza de date
export interface Listing {
  id: string
  title: string
  price: number
  year: number
  mileage: number
  location: string
  category: string
  brand: string
  model: string
  engine_capacity: number
  fuel_type: string
  transmission: string
  condition: string
  description: string
  images: string[]
  seller_id: string
  seller_name: string
  seller_type: 'individual' | 'dealer'
  rating: number
  featured: boolean
  created_at: string
  updated_at: string
}

export interface User {
  id: string
  name: string
  email: string
  phone?: string
  location?: string
  avatar_url?: string
  verified: boolean
  created_at: string
}

// Lista ora»ôelor din Rom√¢nia
export const romanianCities = [
  'Bucure»ôti', 'Cluj-Napoca', 'Timi»ôoara', 'Ia»ôi', 'Constan»õa', 'Craiova', 'Bra»ôov', 'Gala»õi',
  'Ploie»ôti', 'Oradea', 'BacƒÉu', 'Pite»ôti', 'Arad', 'Sibiu', 'T√¢rgu Mure»ô', 'Baia Mare',
  'BuzƒÉu', 'Boto»ôani', 'Satu Mare', 'R√¢mnicu V√¢lcea', 'Drobeta-Turnu Severin', 'Suceava',
  'Piatra Neam»õ', 'T√¢rgu Jiu', 'Tulcea', 'Foc»ôani', 'Bistri»õa', 'Re»ôi»õa', 'Alba Iulia',
  'Deva', 'Hunedoara', 'Slatina', 'Vaslui', 'CƒÉlƒÉra»ôi', 'Giurgiu', 'Slobozia', 'ZalƒÉu',
  'Turda', 'Media»ô', 'One»ôti', 'Gheorgheni', 'Pa»ôcani', 'Dej', 'Reghin', 'Roman',
  'C√¢mpina', 'Caracal', 'FƒÉgƒÉra»ô', 'Lugoj', 'Mangalia', 'Moreni', 'Olteni»õa', 'Petro»ôani',
  'R√¢mnicu SƒÉrat', 'Ro»ôiorii de Vede', 'SƒÉcele', 'Sebe»ô', 'Sf√¢ntu Gheorghe', 'Tecuci',
  'Topli»õa', 'Voluntari', 'Pantelimon', 'Pope»ôti-Leordeni', 'Chiajna', 'Otopeni',
  'Sector 1', 'Sector 2', 'Sector 3', 'Sector 4', 'Sector 5', 'Sector 6',
  'Bragadiru', 'Buftea', 'Chitila', 'Corbeanca', 'Domne»ôti', 'MƒÉgurele', 'Mogo»ôoaia',
  'Cernica', 'Glina', 'Jilava', 'Peris', 'Snagov', 'Stefanestii de Jos', 'Tunari',
  'Flore»ôti', 'Apahida', 'Baciu', 'Feleacu', 'GilƒÉu', 'Jucu', 'Kolozsvar',
  'DumbrƒÉvi»õa', 'Ghiroda', 'Giroc', 'Mo»ôni»õa NouƒÉ', 'Pi»ôchia', 'Remetea Mare',
  'Rediu', 'Miroslava', 'Popricani', 'Tome»ôti', 'Valea Lupului', 'Ciurea',
  'Mamaia', 'Eforie Nord', 'Eforie Sud', 'Neptun', 'Olimp', 'Costine»ôti',
  'Predeal', 'Sinaia', 'Bu»ôteni', 'Azuga', 'C√¢mpulung', 'Mioveni',
  'Drobeta Turnu Severin', 'BƒÉile»ôti', 'Calafat', 'Filia»ôi', 'Motru', 'Segarcea'
];

// Func»õie pentru a crea profilul manual dacƒÉ nu existƒÉ
const ensureProfileExists = async (user: any, userData?: any) => {
  try {
    console.log('üîç Checking if profile exists for user:', user.email)
    
    // VerificƒÉm dacƒÉ profilul existƒÉ deja
    const { data: existingProfile, error: checkError } = await supabase
      .from('profiles')
      .select('*')
      .eq('user_id', user.id)
      .single()
    
    if (existingProfile && !checkError) {
      console.log('‚úÖ Profile already exists for user:', user.email)
      return existingProfile
    }
    
    console.log('‚ùå Profile not found, creating new profile for:', user.email)
    
    // DacƒÉ nu existƒÉ, √Æl creƒÉm
    const profileData = {
      user_id: user.id,
      name: userData?.name || user.user_metadata?.name || user.email?.split('@')[0] || 'Utilizator',
      email: user.email,
      phone: userData?.phone || user.user_metadata?.phone || '',
      location: userData?.location || user.user_metadata?.location || '',
      seller_type: userData?.sellerType || user.user_metadata?.sellerType || 'individual',
      verified: false,
      rating: 0,
      reviews_count: 0
    }
    
    console.log('üìù Creating profile with data:', profileData)
    
    const { data: newProfile, error: createError } = await supabase
      .from('profiles')
      .insert([profileData])
      .select()
      .single()
    
    if (createError) {
      console.error('‚ùå Error creating profile:', createError)
      throw createError
    }
    
    console.log('‚úÖ Profile created successfully:', newProfile)
    return newProfile
  } catch (err) {
    console.error('üí• Error in ensureProfileExists:', err)
    throw err
  }
}

// Func»õii pentru autentificare
export const auth = {
  signUp: async (email: string, password: string, userData: any) => {
    try {
      console.log('üöÄ Starting signup process for:', email)
      
      const { data, error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          data: userData,
        }
      })
      
      if (error) {
        console.error('‚ùå Signup error:', error)
        return { data, error }
      }
      
      if (data.user) {
        console.log('üë§ User created, ensuring profile exists...')
        try {
          await ensureProfileExists(data.user, userData)
        } catch (profileError) {
          console.error('‚ö†Ô∏è Profile creation failed during signup:', profileError)
          // Nu returnƒÉm eroare aici pentru cƒÉ utilizatorul a fost creat cu succes
        }
      }
      
      return { data, error }
    } catch (err) {
      console.error('üí• SignUp error:', err)
      return { data: null, error: err }
    }
  },

  signIn: async (email: string, password: string) => {
    try {
      console.log('üîê Starting signin process for:', email)
      
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password
      })
      
      if (error) {
        console.error('‚ùå Signin error:', error)
        return { data, error }
      }
      
      if (data.user) {
        console.log('‚úÖ User signed in successfully:', data.user.email)
        
        try {
          // AsigurƒÉm cƒÉ profilul existƒÉ
          const profile = await ensureProfileExists(data.user)
          
          if (profile) {
            // SalvƒÉm datele utilizatorului √Æn localStorage pentru acces rapid
            const userData = {
              id: data.user.id,
              name: profile.name,
              email: profile.email,
              sellerType: profile.seller_type,
              isLoggedIn: true
            }
            
            localStorage.setItem('user', JSON.stringify(userData))
            console.log('üíæ User data saved to localStorage:', userData)
          }
        } catch (profileError) {
          console.error('‚ö†Ô∏è Profile handling failed during signin:', profileError)
          // SalvƒÉm mƒÉcar datele de bazƒÉ
          const userData = {
            id: data.user.id,
            name: data.user.email?.split('@')[0] || 'Utilizator',
            email: data.user.email,
            sellerType: 'individual',
            isLoggedIn: true
          }
          localStorage.setItem('user', JSON.stringify(userData))
        }
      }
      
      return { data, error }
    } catch (err) {
      console.error('üí• SignIn error:', err)
      return { data: null, error: err }
    }
  },

  signOut: async () => {
    console.log('üëã Signing out user...')
    localStorage.removeItem('user')
    const { error } = await supabase.auth.signOut()
    return { error }
  },

  getCurrentUser: async () => {
    const { data: { user } } = await supabase.auth.getUser()
    return user
  },
  
  resetPassword: async (email: string) => {
    const { data, error } = await supabase.auth.resetPasswordForEmail(email, {
      redirectTo: `${window.location.origin}/auth/reset-password`,
    })
    return { data, error }
  },

  updatePassword: async (newPassword: string) => {
    try {
      const { data, error } = await supabase.auth.updateUser({
        password: newPassword
      })
      
      if (error) {
        console.error('‚ùå Error updating password:', error)
        return { data: null, error }
      }
      
      console.log('‚úÖ Password updated successfully')
      return { data, error: null }
    } catch (err) {
      console.error('üí• Error updating password:', err)
      return { data: null, error: err }
    }
  }
}

// Func»õii pentru anun»õuri
export const listings = {
  getAll: async (filters?: any) => {
    try {
      console.log('üîç Fetching all listings from Supabase...')
      
      let query = supabase
        .from('listings')
        .select('*')
        .eq('status', 'active')
        .order('created_at', { ascending: false })

      if (filters) {
        if (filters.category) query = query.eq('category', filters.category.toLowerCase())
        if (filters.brand) query = query.eq('brand', filters.brand)
        if (filters.priceMin) query = query.gte('price', filters.priceMin)
        if (filters.priceMax) query = query.lte('price', filters.priceMax)
        if (filters.yearMin) query = query.gte('year', filters.yearMin)
        if (filters.yearMax) query = query.lte('year', filters.yearMax)
        if (filters.location) query = query.ilike('location', `%${filters.location}%`)
        if (filters.sellerType) query = query.eq('seller_type', filters.sellerType)
        if (filters.condition) query = query.eq('condition', filters.condition)
        if (filters.fuel) query = query.eq('fuel_type', filters.fuel)
        if (filters.transmission) query = query.eq('transmission', filters.transmission)
        if (filters.engineMin) query = query.gte('engine_capacity', filters.engineMin)
        if (filters.engineMax) query = query.lte('engine_capacity', filters.engineMax)
        if (filters.mileageMax) query = query.lte('mileage', filters.mileageMax)
      }

      const { data, error } = await query
      
      if (error) {
        console.error('‚ùå Error fetching listings:', error)
        return { data: null, error }
      }
      
      console.log(`‚úÖ Successfully fetched ${data?.length || 0} listings`)
      return { data, error: null }
    } catch (err) {
      console.error('üí• Error in listings.getAll:', err)
      return { data: null, error: err }
    }
  },

  getById: async (id: string) => {
    try {
      const { data, error } = await supabase
        .from('listings')
        .select('*')
        .eq('id', id)
        .single()
      
      // IncrementƒÉm numƒÉrul de vizualizƒÉri
      if (data && !error) {
        await supabase
          .from('listings')
          .update({ views_count: (data.views_count || 0) + 1 })
          .eq('id', id)
      }
      
      return { data, error }
    } catch (err) {
      console.error('Error fetching listing:', err)
      return { data: null, error: err }
    }
  },

  create: async (listing: Partial<Listing>, images: File[]) => {
    try {
      console.log('üöÄ Starting listing creation process...')
      
      // 1. Ob»õinem utilizatorul curent
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) {
        throw new Error('Utilizatorul nu este autentificat')
      }
      
      console.log('üë§ Current user:', user.email)
      
      // 2. Ob»õinem profilul utilizatorului pentru a avea seller_id corect
      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('id, name, seller_type')
        .eq('user_id', user.id)
        .single()
      
      if (profileError || !profile) {
        console.error('‚ùå Profile not found:', profileError)
        throw new Error('Profilul utilizatorului nu a fost gƒÉsit. Te rugƒÉm sƒÉ-»õi completezi profilul mai √Ænt√¢i.')
      }
      
      console.log('‚úÖ Profile found:', profile)
      
      // 3. VerificƒÉm dacƒÉ bucket-ul existƒÉ, dacƒÉ nu √Æl creƒÉm
      const { data: buckets, error: bucketsError } = await supabase.storage.listBuckets()
      
      if (bucketsError) {
        console.error('‚ùå Error checking buckets:', bucketsError)
      }
      
      const listingImagesBucket = buckets?.find(bucket => bucket.name === 'listing-images')
      
      if (!listingImagesBucket) {
        console.log('üì¶ Creating listing-images bucket...')
        const { error: createBucketError } = await supabase.storage.createBucket('listing-images', {
          public: true,
          allowedMimeTypes: ['image/jpeg', 'image/png', 'image/webp'],
          fileSizeLimit: 5242880 // 5MB
        })
        
        if (createBucketError) {
          console.error('‚ùå Error creating bucket:', createBucketError)
          // ContinuƒÉm fƒÉrƒÉ sƒÉ aruncƒÉm eroare, poate bucket-ul existƒÉ deja
        } else {
          console.log('‚úÖ Bucket created successfully')
        }
      }
      
      // 4. √éncƒÉrcƒÉm imaginile √Æn storage (dacƒÉ existƒÉ)
      const imageUrls: string[] = []
      
      if (images && images.length > 0) {
        console.log(`üì∏ Uploading ${images.length} images...`)
        
        for (const image of images) {
          const fileExt = image.name.split('.').pop()
          const fileName = `${uuidv4()}.${fileExt}`
          const filePath = `${profile.id}/${fileName}`
          
          console.log(`üì§ Uploading image: ${fileName}`)
          
          const { error: uploadError, data: uploadData } = await supabase.storage
            .from('listing-images')
            .upload(filePath, image, {
              cacheControl: '3600',
              upsert: false
            })
          
          if (uploadError) {
            console.error('‚ùå Error uploading image:', uploadError)
            // ContinuƒÉm cu urmƒÉtoarea imagine √Æn loc sƒÉ oprim procesul
            continue
          }
          
          console.log('‚úÖ Image uploaded:', uploadData.path)
          
          // Ob»õinem URL-ul public pentru imagine
          const { data: { publicUrl } } = supabase.storage
            .from('listing-images')
            .getPublicUrl(filePath)
          
          console.log('üîó Public URL:', publicUrl)
          imageUrls.push(publicUrl)
        }
        
        console.log(`‚úÖ Uploaded ${imageUrls.length} images successfully`)
      }
      
      // 5. PregƒÉtim datele pentru anun»õ cu seller_id corect
      const listingData = {
        ...listing,
        id: uuidv4(),
        seller_id: profile.id, // Folosim ID-ul din profiles, nu din auth.users
        seller_name: profile.name,
        seller_type: profile.seller_type,
        images: imageUrls,
        status: 'active',
        views_count: 0,
        favorites_count: 0,
        rating: 0,
        featured: false
      }
      
      console.log('üìù Creating listing with data:', {
        ...listingData,
        images: `${imageUrls.length} images`
      })
      
      // 6. CreƒÉm anun»õul √Æn baza de date
      const { data, error } = await supabase
        .from('listings')
        .insert([listingData])
        .select()
        .single()
      
      if (error) {
        console.error('‚ùå Error creating listing:', error)
        throw new Error(`Eroare la crearea anun»õului: ${error.message}`)
      }
      
      console.log('‚úÖ Listing created successfully:', data.id)
      return { data, error: null }
      
    } catch (err: any) {
      console.error('üí• Error in listings.create:', err)
      return { data: null, error: err }
    }
  },

  update: async (id: string, updates: Partial<Listing>, newImages?: File[]) => {
    try {
      // DacƒÉ avem imagini noi, le √ÆncƒÉrcƒÉm
      if (newImages && newImages.length > 0) {
        const imageUrls: string[] = []
        
        // Ob»õinem anun»õul curent pentru a pƒÉstra imaginile existente
        const { data: currentListing } = await supabase
          .from('listings')
          .select('images, seller_id')
          .eq('id', id)
          .single()
        
        // PƒÉstrƒÉm imaginile existente
        if (currentListing && currentListing.images) {
          imageUrls.push(...currentListing.images)
        }
        
        // AdƒÉugƒÉm imaginile noi
        for (const image of newImages) {
          const fileExt = image.name.split('.').pop()
          const fileName = `${uuidv4()}.${fileExt}`
          const filePath = `${currentListing?.seller_id}/${fileName}`
          
          const { error: uploadError } = await supabase.storage
            .from('listing-images')
            .upload(filePath, image)
          
          if (uploadError) {
            console.error('Error uploading image:', uploadError)
            continue
          }
          
          // Ob»õinem URL-ul public pentru imagine
          const { data: { publicUrl } } = supabase.storage
            .from('listing-images')
            .getPublicUrl(filePath)
          
          imageUrls.push(publicUrl)
        }
        
        // ActualizƒÉm anun»õul cu noile imagini
        updates.images = imageUrls
      }
      
      const { data, error } = await supabase
        .from('listings')
        .update(updates)
        .eq('id', id)
        .select()
      
      return { data, error }
    } catch (err) {
      console.error('Error updating listing:', err)
      return { data: null, error: err }
    }
  },

  delete: async (id: string) => {
    try {
      // Ob»õinem anun»õul pentru a »ôterge imaginile
      const { data: listing } = await supabase
        .from('listings')
        .select('images')
        .eq('id', id)
        .single()
      
      // »òtergem imaginile din storage
      if (listing && listing.images) {
        for (const imageUrl of listing.images) {
          // Extragem path-ul din URL
          const urlParts = imageUrl.split('/')
          const fileName = urlParts[urlParts.length - 1]
          const sellerFolder = urlParts[urlParts.length - 2]
          const filePath = `${sellerFolder}/${fileName}`
          
          await supabase.storage
            .from('listing-images')
            .remove([filePath])
        }
      }
      
      // »òtergem anun»õul
      const { error } = await supabase
        .from('listings')
        .delete()
        .eq('id', id)
      
      return { error }
    } catch (err) {
      console.error('Error deleting listing:', err)
      return { error: err }
    }
  },
  
  addToFavorites: async (userId: string, listingId: string) => {
    try {
      const { data, error } = await supabase
        .from('favorites')
        .insert([{ user_id: userId, listing_id: listingId }])
        .select()
      
      return { data, error }
    } catch (err) {
      console.error('Error adding to favorites:', err)
      return { data: null, error: err }
    }
  },
  
  removeFromFavorites: async (userId: string, listingId: string) => {
    try {
      const { error } = await supabase
        .from('favorites')
        .delete()
        .match({ user_id: userId, listing_id: listingId })
      
      return { error }
    } catch (err) {
      console.error('Error removing from favorites:', err)
      return { error: err }
    }
  },
  
  getFavorites: async (userId: string) => {
    try {
      const { data, error } = await supabase
        .from('favorites')
        .select(`
          listing_id,
          listings (*)
        `)
        .eq('user_id', userId)
      
      return { data, error }
    } catch (err) {
      console.error('Error fetching favorites:', err)
      return { data: null, error: err }
    }
  },

  checkIfFavorite: async (userId: string, listingId: string) => {
    try {
      const { data, error } = await supabase
        .from('favorites')
        .select('*')
        .eq('user_id', userId)
        .eq('listing_id', listingId)
      
      if (error) {
        console.error('Error checking if favorite:', error)
        return { isFavorite: false, error }
      }
      
      // Check if data array has any items (favorite exists)
      const isFavorite = data && data.length > 0
      
      return { isFavorite, error: null }
    } catch (err) {
      console.error('Error checking if favorite:', err)
      return { isFavorite: false, error: err }
    }
  }
}

// Func»õii pentru profiluri
export const profiles = {
  getById: async (userId: string) => {
    try {
      const { data, error } = await supabase
        .from('profiles')
        .select('*')
        .eq('user_id', userId)
        .single()
      
      return { data, error }
    } catch (err) {
      console.error('Error fetching profile:', err)
      return { data: null, error: err }
    }
  },
  
  update: async (userId: string, updates: Partial<User>) => {
    try {
      const { data, error } = await supabase
        .from('profiles')
        .update(updates)
        .eq('user_id', userId)
        .select()
      
      return { data, error }
    } catch (err) {
      console.error('Error updating profile:', err)
      return { data: null, error: err }
    }
  },
  
  uploadAvatar: async (userId: string, file: File) => {
    try {
      const fileExt = file.name.split('.').pop()
      const fileName = `${uuidv4()}.${fileExt}`
      const filePath = `${userId}/${fileName}`
      
      const { error: uploadError } = await supabase.storage
        .from('profile-images')
        .upload(filePath, file)
      
      if (uploadError) {
        return { error: uploadError }
      }
      
      // Ob»õinem URL-ul public pentru avatar
      const { data: { publicUrl } } = supabase.storage
        .from('profile-images')
        .getPublicUrl(filePath)
      
      // ActualizƒÉm profilul cu noul avatar
      const { data, error } = await supabase
        .from('profiles')
        .update({ avatar_url: publicUrl })
        .eq('user_id', userId)
        .select()
      
      return { data, error }
    } catch (err) {
      console.error('Error uploading avatar:', err)
      return { data: null, error: err }
    }
  }
}

// Func»õii pentru mesaje
export const messages = {
  send: async (senderId: string, receiverId: string, listingId: string, content: string, subject?: string) => {
    try {
      const { data, error } = await supabase
        .from('messages')
        .insert([{
          sender_id: senderId,
          receiver_id: receiverId,
          listing_id: listingId,
          content,
          subject,
          id: uuidv4()
        }])
        .select()
      
      return { data, error }
    } catch (err) {
      console.error('Error sending message:', err)
      return { data: null, error: err }
    }
  },
  
  getConversations: async (userId: string) => {
    try {
      const { data, error } = await supabase
        .from('messages')
        .select('*')
        .or(`sender_id.eq.${userId},receiver_id.eq.${userId}`)
        .order('created_at', { ascending: false })
      
      return { data, error }
    } catch (err) {
      console.error('Error fetching conversations:', err)
      return { data: null, error: err }
    }
  },
  
  markAsRead: async (messageId: string) => {
    try {
      const { data, error } = await supabase
        .from('messages')
        .update({ read: true })
        .eq('id', messageId)
        .select()
      
      return { data, error }
    } catch (err) {
      console.error('Error marking message as read:', err)
      return { data: null, error: err }
    }
  }
}

// Func»õii pentru recenzii
export const reviews = {
  create: async (reviewerId: string, reviewedId: string, listingId: string, rating: number, comment?: string) => {
    try {
      const { data, error } = await supabase
        .from('reviews')
        .insert([{
          reviewer_id: reviewerId,
          reviewed_id: reviewedId,
          listing_id: listingId,
          rating,
          comment,
          id: uuidv4()
        }])
        .select()
      
      // ActualizƒÉm rating-ul mediu pentru utilizatorul evaluat
      if (!error) {
        // Ob»õinem toate recenziile pentru utilizator
        const { data: userReviews } = await supabase
          .from('reviews')
          .select('rating')
          .eq('reviewed_id', reviewedId)
        
        if (userReviews) {
          // CalculƒÉm media
          const avgRating = userReviews.reduce((sum, review) => sum + review.rating, 0) / userReviews.length
          
          // ActualizƒÉm profilul
          await supabase
            .from('profiles')
            .update({ 
              rating: parseFloat(avgRating.toFixed(2)),
              reviews_count: userReviews.length
            })
            .eq('user_id', reviewedId)
        }
      }
      
      return { data, error }
    } catch (err) {
      console.error('Error creating review:', err)
      return { data: null, error: err }
    }
  },
  
  getForUser: async (userId: string) => {
    try {
      const { data, error } = await supabase
        .from('reviews')
        .select('*')
        .eq('reviewed_id', userId)
        .order('created_at', { ascending: false })
      
      return { data, error }
    } catch (err) {
      console.error('Error fetching reviews:', err)
      return { data: null, error: err }
    }
  }
}

// Func»õie pentru a verifica dacƒÉ utilizatorul este autentificat
export const isAuthenticated = async () => {
  try {
    const { data: { user } } = await supabase.auth.getUser()
    return !!user
  } catch (err) {
    console.error('Error checking authentication:', err)
    return false
  }
}

// Func»õie pentru a verifica dacƒÉ Supabase este configurat corect
export const checkSupabaseConnection = async () => {
  try {
    const { error } = await supabase.from('profiles').select('count', { count: 'exact', head: true })
    return !error
  } catch (e) {
    console.error('Supabase connection error:', e)
    return false
  }
}

// Func»õie pentru testarea conexiunii complete
export const testConnection = async () => {
  try {
    console.log('üîç Testing Supabase connection...')
    
    // Test 1: Conexiunea de bazƒÉ
    const { data: healthCheck, error: healthError } = await supabase
      .from('profiles')
      .select('count', { count: 'exact', head: true })
    
    if (healthError) {
      console.error('‚ùå Health check failed:', healthError)
      return { success: false, error: 'Database connection failed' }
    }
    
    console.log('‚úÖ Database connection successful')
    
    // Test 2: VerificƒÉm tabelele
    const tables = ['profiles', 'listings', 'favorites', 'messages', 'reviews']
    for (const table of tables) {
      const { error } = await supabase
        .from(table)
        .select('count', { count: 'exact', head: true })
      
      if (error) {
        console.error(`‚ùå Table ${table} not found:`, error)
        return { success: false, error: `Table ${table} missing` }
      }
      console.log(`‚úÖ Table ${table} exists`)
    }
    
    // Test 3: VerificƒÉm storage buckets
    const { data: buckets, error: bucketsError } = await supabase.storage.listBuckets()
    
    if (bucketsError) {
      console.error('‚ùå Storage check failed:', bucketsError)
      return { success: false, error: 'Storage not accessible' }
    }
    
    const requiredBuckets = ['listing-images', 'profile-images']
    const existingBuckets = buckets?.map(b => b.name) || []
    
    for (const bucket of requiredBuckets) {
      if (!existingBuckets.includes(bucket)) {
        console.warn(`‚ö†Ô∏è Bucket ${bucket} not found`)
        
        // CreƒÉm bucket-ul dacƒÉ nu existƒÉ
        console.log(`üì¶ Creating ${bucket} bucket...`)
        const { error: createBucketError } = await supabase.storage.createBucket(bucket, {
          public: true,
          allowedMimeTypes: ['image/jpeg', 'image/png', 'image/webp'],
          fileSizeLimit: 5242880 // 5MB
        })
        
        if (createBucketError) {
          console.error(`‚ùå Error creating ${bucket} bucket:`, createBucketError)
        } else {
          console.log(`‚úÖ Bucket ${bucket} created successfully`)
        }
      } else {
        console.log(`‚úÖ Bucket ${bucket} exists`)
      }
    }
    
    console.log('üéâ All tests passed! Supabase is ready to use.')
    return { success: true, message: 'All systems operational' }
    
  } catch (err) {
    console.error('‚ùå Connection test failed:', err)
    return { success: false, error: 'Unexpected error during testing' }
  }
}

// Func»õie pentru a crea profilul manual pentru utilizatorul existent
export const createMissingProfile = async (userId: string, email: string) => {
  try {
    console.log('üîß Creating missing profile for user:', email)
    
    const profileData = {
      user_id: userId,
      name: email.split('@')[0], // Folosim partea din email ca nume implicit
      email: email,
      phone: '',
      location: '',
      seller_type: 'individual',
      verified: false,
      rating: 0,
      reviews_count: 0
    }
    
    const { data, error } = await supabase
      .from('profiles')
      .insert([profileData])
      .select()
      .single()
    
    if (error) {
      console.error('‚ùå Error creating missing profile:', error)
      throw error
    }
    
    console.log('‚úÖ Missing profile created successfully:', data)
    return { data, error: null }
  } catch (err) {
    console.error('üí• Error in createMissingProfile:', err)
    return { data: null, error: err }
  }
}

// Func»õie pentru a repara utilizatorul curent
export const fixCurrentUserProfile = async () => {
  try {
    console.log('üîß Starting profile repair process...')
    
    // Ob»õinem utilizatorul curent
    const { data: { user }, error: userError } = await supabase.auth.getUser()
    
    if (userError || !user) {
      console.error('‚ùå No authenticated user found:', userError)
      return { success: false, error: 'No authenticated user' }
    }
    
    console.log('üë§ Found authenticated user:', user.email)
    
    // VerificƒÉm dacƒÉ profilul existƒÉ
    const { data: existingProfile, error: profileError } = await supabase
      .from('profiles')
      .select('*')
      .eq('user_id', user.id)
      .single()
    
    if (existingProfile && !profileError) {
      console.log('‚úÖ Profile already exists, updating localStorage...')
      
      // ActualizƒÉm localStorage cu datele corecte
      const userData = {
        id: user.id,
        name: existingProfile.name,
        email: existingProfile.email,
        sellerType: existingProfile.seller_type,
        isLoggedIn: true
      }
      
      localStorage.setItem('user', JSON.stringify(userData))
      return { success: true, message: 'Profile found and localStorage updated' }
    }
    
    // Profilul nu existƒÉ, √Æl creƒÉm
    console.log('‚ùå Profile not found, creating new profile...')
    
    const result = await createMissingProfile(user.id, user.email!)
    
    if (result.error) {
      console.error('‚ùå Failed to create profile:', result.error)
      return { success: false, error: 'Failed to create profile' }
    }
    
    // ActualizƒÉm localStorage cu datele noi
    const userData = {
      id: user.id,
      name: result.data!.name,
      email: result.data!.email,
      sellerType: result.data!.seller_type,
      isLoggedIn: true
    }
    
    localStorage.setItem('user', JSON.stringify(userData))
    
    console.log('üéâ Profile repair completed successfully!')
    return { success: true, message: 'Profile created and localStorage updated' }
    
  } catch (err) {
    console.error('üí• Error in fixCurrentUserProfile:', err)
    return { success: false, error: 'Unexpected error during repair' }
  }
}